"use strict";(self.webpackChunkgo_beyond=self.webpackChunkgo_beyond||[]).push([[352],{8295:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},4043:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>e,data:()=>t});var n=a(4691);const l={},e=(0,a(8295).A)(l,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="设计原则与思想" tabindex="-1"><a class="header-anchor" href="#设计原则与思想"><span>设计原则与思想</span></a></h1><h3 id="面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。" tabindex="-1"><a class="header-anchor" href="#面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。"><span>面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。</span></a></h3><figure><img src="https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>面向对象编程因为具有丰富的特性(抽象、封装、继承、多态)，可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li><li>设计原则是指导我们代码设计的一些经验总结，对与某些场景下，是否应该应用某种设计模式具有指导意义，比如，开闭原则是很多设计模式(策略、模板等)的指导原则。</li><li>设计模式是针对软件开发过程中常遇到一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是<strong>提高代码的可扩展性</strong>。从抽象程度上来说，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li><li>编程规范主要解决的是代码的<strong>可读性问题</strong>。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li><li>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li></ul><p>​ 实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。</p><h2 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象"><span>面向对象</span></a></h2><h3 id="面向对象编程和面向对象编程语言" tabindex="-1"><a class="header-anchor" href="#面向对象编程和面向对象编程语言"><span>面向对象编程和面向对象编程语言</span></a></h3><ul><li><strong>面向对象编程</strong>是一种编程范式或者编程风格，<strong>他以类和对象作为组织代码基本单元</strong>，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。</li><li><strong>面向对象编程语言</strong>是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li></ul><h3 id="面向对象分析和面向对象设计" tabindex="-1"><a class="header-anchor" href="#面向对象分析和面向对象设计"><span>面向对象分析和面向对象设计</span></a></h3><ul><li><p>面向对象分析与设计中的“分析”和“设计”这两个词，我们完全可以从字面上去理解，不需要过度解读，简单类比软件开发中的需求分析、系统设计即可。是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。</p></li><li><p>简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。</p></li></ul><h2 id="面向对象四大特性" tabindex="-1"><a class="header-anchor" href="#面向对象四大特性"><span>面向对象四大特性</span></a></h2><h3 id="封装-encapsulation" tabindex="-1"><a class="header-anchor" href="#封装-encapsulation"><span>封装（Encapsulation）</span></a></h3><p>WHAT:封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。</p><p>封装特性存在的意义:一方面是<strong>保护数据不被随意修改</strong>，提高代码的可维护性；另一方面是仅暴露有限的必要接口，<strong>提高类的易用性。</strong></p><h3 id="抽象-abstraction" tabindex="-1"><a class="header-anchor" href="#抽象-abstraction"><span>抽象（Abstraction）</span></a></h3><ul><li>WHAT:封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。(通过接口Interface和抽象类abstract实现)。</li><li>WHY:在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。</li><li>抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息</li></ul><h3 id="继承-inheritance" tabindex="-1"><a class="header-anchor" href="#继承-inheritance"><span>继承（Inheritance）</span></a></h3><ul><li>WHAT:继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</li><li>WHY: 代码复用，不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。</li><li>继承主要是用来解决代码复用的问题。</li></ul><h3 id="多态-polymorphism" tabindex="-1"><a class="header-anchor" href="#多态-polymorphism"><span>多态（Polymorphism）</span></a></h3><ul><li>WHAT:多态是指子类可以替代父类，在代码运行的过程中，调用子类的实现方法。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。</li><li>多态可以提高代码的<strong>扩展性和复用性</strong>，是很多设计模式、设计原则、编程技巧的代码实现基础。</li></ul><h2 id="面向对象编程与面向过程编程的区别" tabindex="-1"><a class="header-anchor" href="#面向对象编程与面向过程编程的区别"><span>面向对象编程与面向过程编程的区别</span></a></h2><h3 id="面向过程编程与面向过程编程语言" tabindex="-1"><a class="header-anchor" href="#面向过程编程与面向过程编程语言"><span>面向过程编程与面向过程编程语言</span></a></h3><ul><li>面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。</li></ul><h3 id="面向对象编程相比面向过程编程有哪些优势" tabindex="-1"><a class="header-anchor" href="#面向对象编程相比面向过程编程有哪些优势"><span>面向对象编程相比面向过程编程有哪些优势</span></a></h3><ul><li>面向对象更能应对大型负责的系统：对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>更加容易的编写出易扩展、易复用、易维护的程序:面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>更加人性化，更智能，更好理解:从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><h3 id="_08-理论五-抽象类和接口的区别-如何用普通类模拟抽象类和接口" tabindex="-1"><a class="header-anchor" href="#_08-理论五-抽象类和接口的区别-如何用普通类模拟抽象类和接口"><span>08|理论五：抽象类和接口的区别?如何用普通类模拟抽象类和接口？</span></a></h3><ul><li><p>抽象类和接口的语法特性</p><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p></li><li><p>抽象类和接口存在的意义</p><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p>从类的继承层次来看，抽象类是一种自下而上的结构，现有子类的代码重复，然后抽象成上层的父类（抽象类）。而接口正好相反，是一种自上而下的结构，我们在设计接口的时候，是先设计好接口，再去考虑具体的实现。</p></li><li><p>抽象类和接口应用场景的区别</p><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。<strong>如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示\b一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口</strong>。</p></li></ul><h3 id="_09-理论六-为什么要基于接口编程-有必要为每一个类设计接口吗" tabindex="-1"><a class="header-anchor" href="#_09-理论六-为什么要基于接口编程-有必要为每一个类设计接口吗"><span>09|理论六：为什么要基于接口编程？有必要为每一个类设计接口吗？</span></a></h3><p><strong>我们在做软件开发的时候，一定要有接口意识、封装意识、抽象意识。</strong></p><ul><li><p>基于接口而非实现编程的原则：将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。以此来降低代码之间的耦合，提高代码的扩展性。</p></li><li><p>如何解读原则中的“接口”二字？</p></li><li><p>“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p></li><li><p>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</p></li><li><p>“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p></li></ul><h3 id="_10-理论七-为什么要多用组合少用继承-如何决定该用组合还是继承" tabindex="-1"><a class="header-anchor" href="#_10-理论七-为什么要多用组合少用继承-如何决定该用组合还是继承"><span>10|理论七：为什么要多用组合少用继承？如何决定该用组合还是继承？</span></a></h3><ul><li><p>为什么不推荐使用继承？</p><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p></li><li><p>组合相比继承具有哪些优势？</p><p>继承有三个作用：表示is-a的关系、实现多态和代码复用，而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p></li><li><p>如何判断改用组合还是继承？</p><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p></li></ul><h2 id="三-设计原则与思想-设计原则-12" tabindex="-1"><a class="header-anchor" href="#三-设计原则与思想-设计原则-12"><span>三.设计原则与思想：设计原则(12)</span></a></h2><p>经典设计原则，SOLID、KISS、YAGNI、DRY、LOD</p><h4 id="_10-理论一-单一职责原则-如何判定某个类的职责是否够-单一" tabindex="-1"><a class="header-anchor" href="#_10-理论一-单一职责原则-如何判定某个类的职责是否够-单一"><span>10|理论一：单一职责原则，如何判定某个类的职责是否够”单一“？</span></a></h4><ul><li><p>如何理解单一职责原则？（Single Responsibility Principle）？</p><p>A class or module should have a single reponsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。</p></li><li><p>如何判断类的指责是否单一？</p><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul></li></ul><h4 id="_11-理论二-如何做到-对扩展开放、对修改封闭-扩展和修改各指什么" tabindex="-1"><a class="header-anchor" href="#_11-理论二-如何做到-对扩展开放、对修改封闭-扩展和修改各指什么"><span>11|理论二：如何做到”对扩展开放、对修改封闭“？扩展和修改各指什么？</span></a></h4><ul><li><p>如何理解“对扩展开放、修改关闭”？（开闭原则）</p><p>开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p></li><li><p>如何做到”对扩展开放、对修改封闭“？</p><p>要有 <strong>扩展意识、抽象意识、封装意识</strong></p><p>常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程。以及23种设计模式。</p></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 这一部分体现了抽象意识</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //... }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> KafkaMessageQueue</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //... }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RocketMQMessageQueue</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//...}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageFormatter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //... }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> JsonMessageFormatter</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageFormatter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//...}</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageFormatter</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageFormatter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//...}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageQueue</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> msgQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 基于接口而非实现编程</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MessageQueue</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> msgQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 依赖注入</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">msgQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> msgQueue;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // msgFormatter：多态、依赖注入</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sendNotification</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Notification</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> notification</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MessageFormatter</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> msgFormatter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //...    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_12-理论三-里氏替换原则-lsp-与多态有何区别-哪些是违反了里氏替换原则" tabindex="-1"><a class="header-anchor" href="#_12-理论三-里氏替换原则-lsp-与多态有何区别-哪些是违反了里氏替换原则"><span>12|理论三：里氏替换原则(LSP)与多态有何区别？哪些是违反了里氏替换原则</span></a></h4><p>Liskov substitution principle</p><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><ul><li>多态是面向对象编程的一种特性，是面向对象编程语言的一种语法机制，是面向对象编程的一种代码实现思路。而LSP是一种设计原则，是在实现继承关系时设计子类的一种指导思想。子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</li><li>里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是**“Design By Contract”，中文翻译就是“按照协议来设计”**。</li><li>违背LSP原则的例子：子类违背父类声明要实现的功能、<strong>子类违背父类对输入、输出、异常的约定</strong>、子类违背父类注释中所罗列的任何特殊说明。</li></ul><h4 id="_18-理论四-接口隔离原则-isp-有哪些应用-原则中的-接口-该如何理解" tabindex="-1"><a class="header-anchor" href="#_18-理论四-接口隔离原则-isp-有哪些应用-原则中的-接口-该如何理解"><span>18|理论四：接口隔离原则（ISP）有哪些应用？原则中的”接口&quot;该如何理解?</span></a></h4><ul><li><p>如何理解”接口隔离原则“？Interface Segregation Principle</p><p>Clients should not be forced to depend upon interfaces that they do not use ,中文翻译：客户端不应该被强迫依赖它不需要的接口。</p></li><li><p>何为”接口：</p><ul><li><p>**一组 API 接口集合：**在设计微服务或者类接口的时候，如果部分接口只被部分调用者调用，则应该将这部分接口独立出来，单独给对应的调用者调用，而不是强迫其调用者也依赖这部分不会被用到的接口</p></li><li><p>**单个 API 接口或者函数：**函数的功能设计要单一，不要将多个不同的功能逻辑在一个函数中实现。</p><p>接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一</p></li><li><p>**OOP中的接口概念：**如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数</p></li></ul></li></ul><h4 id="_19-理论五-控制反转、依赖反转、依赖注入这三者之间有什么区别和联系" tabindex="-1"><a class="header-anchor" href="#_19-理论五-控制反转、依赖反转、依赖注入这三者之间有什么区别和联系"><span>19|理论五：控制反转、依赖反转、依赖注入这三者之间有什么区别和联系？</span></a></h4><h5 id="控制反转-inversion-of-control-ioc-设计思想" tabindex="-1"><a class="header-anchor" href="#控制反转-inversion-of-control-ioc-设计思想"><span>控制反转（Inversion Of Control,IOC）(设计思想)</span></a></h5><ul><li><p>实际上，<strong>控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计</strong>。这里所说的**“控制”<strong>指的是对程序执行流程的控制，而</strong>“反转”**指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p></li><li><p>实现方式有依赖注入 和模板模式等。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//类似模板模式</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> abstract</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TestCase</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">doTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">      System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Test succeed.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">      System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Test failed.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> abstract</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> doTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> JunitApplication</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> List</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TestCase</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> testCases </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> register</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TestCase</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> testCase</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    testCases</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(testCase);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TestCase</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> case</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> testCases) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      case</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserServiceTest</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TestCase</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> doTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ... </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()。也是为什么用static修饰的原因</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">JunitApplication.register(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> UserServiceTest</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h5 id="依赖注入-dependency-injection-di-编程技巧" tabindex="-1"><a class="header-anchor" href="#依赖注入-dependency-injection-di-编程技巧"><span>依赖注入（Dependency Injection,DI）（编程技巧）</span></a></h5><ul><li>简单的讲：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</li></ul><h5 id="依赖注入框架-dependency-injection-framework-dif" tabindex="-1"><a class="header-anchor" href="#依赖注入框架-dependency-injection-framework-dif"><span>依赖注入框架（Dependency Injection Framework,DIF）</span></a></h5><ul><li>我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</li><li>实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。</li><li>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。</li></ul><h5 id="依赖反转原则-dependency-inversion-principle-dip" tabindex="-1"><a class="header-anchor" href="#依赖反转原则-dependency-inversion-principle-dip"><span>依赖反转原则（Dependency Inversion Principle,DIP）</span></a></h5><p>也叫依赖倒置原则</p><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><h4 id="_19-理论六-为何说-kiss-原则和-yangi-原则看似简单-但经常被用错" tabindex="-1"><a class="header-anchor" href="#_19-理论六-为何说-kiss-原则和-yangi-原则看似简单-但经常被用错"><span>19|理论六：为何说“KISS”原则和“YANGI”原则看似简单，但经常被用错？</span></a></h4><ul><li><p>如何理解“KISS 原则”？KISS 原则的英文描述有好几个版本，比如下面这几个。</p><p>Keep It Simple and Stupid.</p><p>Keep It Short and Simple.</p><p>Keep It Simple and Straightforward.</p><p>不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。</p><ul><li><p>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</p></li><li><p>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</p></li><li><p>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</p></li></ul></li><li><p>YAGNI 跟 KISS 说的是一回事吗？</p><p>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p></li><li><p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）</p></li></ul><h4 id="_21-理论七-重复的代码就一定违背dry吗-如何提高代码的复用性" tabindex="-1"><a class="header-anchor" href="#_21-理论七-重复的代码就一定违背dry吗-如何提高代码的复用性"><span>21|理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</span></a></h4><p>DRY原则：Don&#39;t repeat yourself 不要写重复的代码</p><p>代码重复、功能语义重复、代码执行重复。</p>',61)]))}]]),t=JSON.parse('{"path":"/architecture-design/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%80%9D%E6%83%B3.html","title":"设计原则与思想","lang":"zh-CN","frontmatter":{"description":"设计原则与思想 面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。 imgimg 面向对象编程因为具有丰富的特性(抽象、封装、继承、多态)，可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则是指导我们代码设计的一些经验总结，对与某些场景下，是否应该应用某种设计模式具有指导意义，比如，开闭原则是很多设计模式(策略、...","head":[["meta",{"property":"og:url","content":"https://sciencefl.github.io/architecture-design/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%80%9D%E6%83%B3.html"}],["meta",{"property":"og:site_name","content":"FlynnDocs 学习笔记"}],["meta",{"property":"og:title","content":"设计原则与思想"}],["meta",{"property":"og:description","content":"设计原则与思想 面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。 imgimg 面向对象编程因为具有丰富的特性(抽象、封装、继承、多态)，可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则是指导我们代码设计的一些经验总结，对与某些场景下，是否应该应用某种设计模式具有指导意义，比如，开闭原则是很多设计模式(策略、..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-26T15:22:07.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-26T15:22:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计原则与思想\\",\\"image\\":[\\"https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png\\"],\\"dateModified\\":\\"2024-11-26T15:22:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flynn\\",\\"url\\":\\"https://sciencefl.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。","slug":"面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。","link":"#面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。","children":[]},{"level":2,"title":"面向对象","slug":"面向对象","link":"#面向对象","children":[{"level":3,"title":"面向对象编程和面向对象编程语言","slug":"面向对象编程和面向对象编程语言","link":"#面向对象编程和面向对象编程语言","children":[]},{"level":3,"title":"面向对象分析和面向对象设计","slug":"面向对象分析和面向对象设计","link":"#面向对象分析和面向对象设计","children":[]}]},{"level":2,"title":"面向对象四大特性","slug":"面向对象四大特性","link":"#面向对象四大特性","children":[{"level":3,"title":"封装（Encapsulation）","slug":"封装-encapsulation","link":"#封装-encapsulation","children":[]},{"level":3,"title":"抽象（Abstraction）","slug":"抽象-abstraction","link":"#抽象-abstraction","children":[]},{"level":3,"title":"继承（Inheritance）","slug":"继承-inheritance","link":"#继承-inheritance","children":[]},{"level":3,"title":"多态（Polymorphism）","slug":"多态-polymorphism","link":"#多态-polymorphism","children":[]}]},{"level":2,"title":"面向对象编程与面向过程编程的区别","slug":"面向对象编程与面向过程编程的区别","link":"#面向对象编程与面向过程编程的区别","children":[{"level":3,"title":"面向过程编程与面向过程编程语言","slug":"面向过程编程与面向过程编程语言","link":"#面向过程编程与面向过程编程语言","children":[]},{"level":3,"title":"面向对象编程相比面向过程编程有哪些优势","slug":"面向对象编程相比面向过程编程有哪些优势","link":"#面向对象编程相比面向过程编程有哪些优势","children":[]},{"level":3,"title":"08|理论五：抽象类和接口的区别?如何用普通类模拟抽象类和接口？","slug":"_08-理论五-抽象类和接口的区别-如何用普通类模拟抽象类和接口","link":"#_08-理论五-抽象类和接口的区别-如何用普通类模拟抽象类和接口","children":[]},{"level":3,"title":"09|理论六：为什么要基于接口编程？有必要为每一个类设计接口吗？","slug":"_09-理论六-为什么要基于接口编程-有必要为每一个类设计接口吗","link":"#_09-理论六-为什么要基于接口编程-有必要为每一个类设计接口吗","children":[]},{"level":3,"title":"10|理论七：为什么要多用组合少用继承？如何决定该用组合还是继承？","slug":"_10-理论七-为什么要多用组合少用继承-如何决定该用组合还是继承","link":"#_10-理论七-为什么要多用组合少用继承-如何决定该用组合还是继承","children":[]}]},{"level":2,"title":"三.设计原则与思想：设计原则(12)","slug":"三-设计原则与思想-设计原则-12","link":"#三-设计原则与思想-设计原则-12","children":[]}],"git":{"createdTime":1732612569000,"updatedTime":1732634527000,"contributors":[{"name":"fuliang","email":"fuliang@ssc-hn.com","commits":3}]},"readingTime":{"minutes":19.48,"words":5844},"filePathRelative":"architecture-design/设计原则与思想.md","localizedDate":"2024年11月26日","excerpt":"\\n<h3>面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。</h3>\\n<figure><img src=\\"https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png\\" alt=\\"img\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>img</figcaption></figure>\\n<ul>\\n<li>面向对象编程因为具有丰富的特性(抽象、封装、继承、多态)，可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li>\\n<li>设计原则是指导我们代码设计的一些经验总结，对与某些场景下，是否应该应用某种设计模式具有指导意义，比如，开闭原则是很多设计模式(策略、模板等)的指导原则。</li>\\n<li>设计模式是针对软件开发过程中常遇到一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是<strong>提高代码的可扩展性</strong>。从抽象程度上来说，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li>\\n<li>编程规范主要解决的是代码的<strong>可读性问题</strong>。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li>\\n<li>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li>\\n</ul>","autoDesc":true}')}}]);