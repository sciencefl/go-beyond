# 设计原则与思想

### 面向对象、设计原则、设计模式、编程规范、重构技巧之间的关系。

![img](https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png)

- 面向对象编程因为具有丰富的特性(抽象、封装、继承、多态)，可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。
- 设计原则是指导我们代码设计的一些经验总结，对与某些场景下，是否应该应用某种设计模式具有指导意义，比如，开闭原则是很多设计模式(策略、模板等)的指导原则。
- 设计模式是针对软件开发过程中常遇到一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是**提高代码的可扩展性**。从抽象程度上来说，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。
- 编程规范主要解决的是代码的**可读性问题**。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。
- 重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。

​			实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。

## 面向对象

### 面向对象编程和面向对象编程语言

- **面向对象编程**是一种编程范式或者编程风格，**他以类和对象作为组织代码基本单元**，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。
- **面向对象编程语言**是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

### 面向对象分析和面向对象设计

- 面向对象分析与设计中的“分析”和“设计”这两个词，我们完全可以从字面上去理解，不需要过度解读，简单类比软件开发中的需求分析、系统设计即可。是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。

- 简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。

## 面向对象四大特性

### 封装（Encapsulation）

WHAT:封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。

封装特性存在的意义:一方面是**保护数据不被随意修改**，提高代码的可维护性；另一方面是仅暴露有限的必要接口，**提高类的易用性。**

### 抽象（Abstraction）

- WHAT:封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。(通过接口Interface和抽象类abstract实现)。
- WHY:在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。
- 抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息

### 继承（Inheritance）

- WHAT:继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。
- WHY: 代码复用，不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。
- 继承主要是用来解决代码复用的问题。

### 多态（Polymorphism）

- WHAT:多态是指子类可以替代父类，在代码运行的过程中，调用子类的实现方法。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。
- 多态可以提高代码的**扩展性和复用性**，是很多设计模式、设计原则、编程技巧的代码实现基础。

## 面向对象编程与面向过程编程的区别

### 面向过程编程与面向过程编程语言

- 面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。

### 面向对象编程相比面向过程编程有哪些优势

- 面向对象更能应对大型负责的系统：对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
- 更加容易的编写出易扩展、易复用、易维护的程序:面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
- 更加人性化，更智能，更好理解:从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。

### 08|理论五：抽象类和接口的区别?如何用普通类模拟抽象类和接口？

- 抽象类和接口的语法特性

  抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。

- 抽象类和接口存在的意义

  抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。

  从类的继承层次来看，抽象类是一种自下而上的结构，现有子类的代码重复，然后抽象成上层的父类（抽象类）。而接口正好相反，是一种自上而下的结构，我们在设计接口的时候，是先设计好接口，再去考虑具体的实现。

- 抽象类和接口应用场景的区别

  什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。**如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口**。

### 09|理论六：为什么要基于接口编程？有必要为每一个类设计接口吗？

**我们在做软件开发的时候，一定要有接口意识、封装意识、抽象意识。**

- 基于接口而非实现编程的原则：将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。以此来降低代码之间的耦合，提高代码的扩展性。

- 如何解读原则中的“接口”二字？
- “基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。

- 我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。
- “基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。



### 10|理论七：为什么要多用组合少用继承？如何决定该用组合还是继承？

- 为什么不推荐使用继承？

  继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

- 组合相比继承具有哪些优势？

  继承有三个作用：表示is-a的关系、实现多态和代码复用，而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

- 如何判断改用组合还是继承？

  尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。

## 三.设计原则与思想：设计原则(12)

经典设计原则，SOLID、KISS、YAGNI、DRY、LOD

#### 10|理论一：单一职责原则，如何判定某个类的职责是否够”单一“？

- 如何理解单一职责原则？（Single Responsibility Principle）？

  A class or module should have a single reponsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。

- 如何判断类的指责是否单一？

  不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：

  - 类中的代码行数、函数或者属性过多；
  - 类依赖的其他类过多，或者依赖类的其他类过多；
  - 私有方法过多；
  - 比较难给类起一个合适的名字；
  - 类中大量的方法都是集中操作类中的某几个属性。

#### 11|理论二：如何做到”对扩展开放、对修改封闭“？扩展和修改各指什么？

- 如何理解“对扩展开放、修改关闭”？（开闭原则）

  开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。

- 如何做到”对扩展开放、对修改封闭“？

  要有 **扩展意识、抽象意识、封装意识**

  常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程。以及23种设计模式。

```java
// 这一部分体现了抽象意识
public interface MessageQueue { //... }
public class KafkaMessageQueue implements MessageQueue { //... }
public class RocketMQMessageQueue implements MessageQueue {//...}

public interface MessageFormatter { //... }
public class JsonMessageFormatter implements MessageFormatter {//...}
public class MessageFormatter implements MessageFormatter {//...}

public class Demo {
  private MessageQueue msgQueue; // 基于接口而非实现编程
  public Demo(MessageQueue msgQueue) { // 依赖注入
    this.msgQueue = msgQueue;
  }
  
  // msgFormatter：多态、依赖注入
  public void sendNotification(Notification notification, MessageFormatter msgFormatter) {
    //...    
  }
}
```

#### 12|理论三：里氏替换原则(LSP)与多态有何区别？哪些是违反了里氏替换原则

Liskov substitution principle

子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

- 多态是面向对象编程的一种特性，是面向对象编程语言的一种语法机制，是面向对象编程的一种代码实现思路。而LSP是一种设计原则，是在实现继承关系时设计子类的一种指导思想。子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。
- 里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是**“Design By Contract”，中文翻译就是“按照协议来设计”**。
- 违背LSP原则的例子：子类违背父类声明要实现的功能、**子类违背父类对输入、输出、异常的约定**、子类违背父类注释中所罗列的任何特殊说明。

#### 18|理论四：接口隔离原则（ISP）有哪些应用？原则中的”接口"该如何理解?

- 如何理解”接口隔离原则“？Interface Segregation Principle

  Clients should not be forced to depend  upon interfaces that they do not use ,中文翻译：客户端不应该被强迫依赖它不需要的接口。

- 何为”接口：

  - **一组 API 接口集合：**在设计微服务或者类接口的时候，如果部分接口只被部分调用者调用，则应该将这部分接口独立出来，单独给对应的调用者调用，而不是强迫其调用者也依赖这部分不会被用到的接口

  - **单个 API 接口或者函数：**函数的功能设计要单一，不要将多个不同的功能逻辑在一个函数中实现。

    接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一

  - **OOP中的接口概念：**如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数

#### 19|理论五：控制反转、依赖反转、依赖注入这三者之间有什么区别和联系？

#####  控制反转（Inversion Of Control,IOC）(设计思想)

- 实际上，**控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计**。这里所说的**“控制”**指的是对程序执行流程的控制，而**“反转”**指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。

- 实现方式有依赖注入 和模板模式等。

  ```java
  //类似模板模式
  public abstract class TestCase {
    public void run() {
      if (doTest()) {
        System.out.println("Test succeed.");
      } else {
        System.out.println("Test failed.");
      }
    }
    
    public abstract boolean doTest();
  }
  
  public class JunitApplication {
    private static final List<TestCase> testCases = new ArrayList<>();
    
    public static void register(TestCase testCase) {
      testCases.add(testCase);
    }
    
    public static final void main(String[] args) {
      for (TestCase case: testCases) {
        case.run();
      }
    }
  public class UserServiceTest extends TestCase {
    @Override
    public boolean doTest() {
      // ... 
    }
  }
  // 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()。也是为什么用static修饰的原因
  JunitApplication.register(new UserServiceTest(); 
  ```

##### 依赖注入（Dependency Injection,DI）（编程技巧）

- 简单的讲：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。

##### 依赖注入框架（Dependency Injection Framework,DIF）

- 我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。
- 实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。
- 实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。

##### 依赖反转原则（Dependency Inversion Principle,DIP）

也叫依赖倒置原则

> High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

#### 19|理论六：为何说“KISS”原则和“YANGI”原则看似简单，但经常被用错？

- 如何理解“KISS 原则”？KISS 原则的英文描述有好几个版本，比如下面这几个。

  Keep It Simple and Stupid.

  Keep It Short and Simple.

  Keep It Simple and Straightforward. 

  不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。

  - 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。

  - 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己实现这些类库，出 bug 的概率会更高，维护的成本也比较高。

  - 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

- YAGNI 跟 KISS 说的是一回事吗？

  YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。

- YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）

#### 21|理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？

DRY原则：Don't repeat yourself 不要写重复的代码

代码重复、功能语义重复、代码执行重复。